---
title: Inside of E2EE
description: Wait... that's illegal
date: 2023-05-23
author: Mester
---

<Warning>This post is still in development, and it's not finished yet!</Warning>

# Welcome

Dear readers, I welcome you all to my Inside of E2EE post. As you can guess from the title, it's going to be about E2EE and how, where, and why it's used. If you're developing your new web app in JS, you're in luck! The post will also include a bunch of example JS code that uses browser native APIs, so you can pretty much implement E2EE anywhere you want.

# Table of contents

<Note>The example codes are actually going to be in TypeScript, but it's not trivial to turn it into pure JavaScript. And besides, nobody uses vanilla JS anyway...</Note>

# What is E2EE?

Obviously, some of you may have only heard of E2EE, but never actually understood what it means.
E2EE stands for "End-to-End-Encryption", which gives a hint on what it does: it encrypts data (which can be anything, text, images, videos, voice calls) between the ends (clients, or the people).

"But Sir, I heard that HTTPS already encrypts my data online, so why would I need E2EE?" Great question, Pete. [HTTPS](https://en.wikipedia.org/wiki/HTTPS) is just an encrypted version of [HTTP](https://en.wikipedia.org/wiki/HTTP), which is the main protocol you use to connect with websites. It's **only used to encrypt the data between you and the website (server)**, so it [the website] can still read your plans for your next date, or see that embarassing picture your mother sent you last week. Actually, they can't just *read* the message, but **change it entirely**. Not just the message itself, but the recipient too for example. So in short, if you use a messaging app which only uses HTTPS for encryption, you're trusting the server to do exactly what you say. With E2EE, control is entirely in your hands.

E2EE solves this issue by **encrypting the data before sending it to the server**, which then delivers it to the chosen recipient(s) (or not, depends on the server), who can then decrypt it. This design makes sure that the server has no access to the plain-text (in other words, unencrypted) data, only you and your recipient(s) do. This also means that any form of "E2EE" which does the encryption on the server and not in the client is **NOT** E2EE.

## So is HTTPS unsecure?

No, not at all. In fact, HTTPS can be more secure than the E2EE in an app you use, depending on the implementation. But it [HTTPS] only prevents third parties from reading your communication between the server. <br/>
Here is an analogy: there is a very high-tech post office that uses letters which self-destruct if anybody touches them, and only the post office can open them safely (that's HTTPS). You send "Hi, please tell Alexa I love her" to this post office. Neither the post deliver guy or that creepy neighbour can read it, but the post office can process it and execute the instruction. 5 years later, you're married. Now, you send a message again, but this time it's "Hi, please tell Alexa eyAiY29udGVudCI6ICJJIGxvdmUgeW91IOKdpO+4jyIgfQ==". The post office has no idea what you're trying to tell her, but they'll forward this letter to her anyway who can actually read it, because she owns a device you gave her as a gift (the E2EE app). This is the difference between HTTPS and E2EE.

## Do I need it?

No.

Oh, you'd like to have an extra layer of security and make sure nobody except you and the recipients can access your messages? Sure thing then.

## Where is it used?

E2EE is used mainly in messaging apps that are designed to be, well... secure. Examples are [Matrix](https://matrix.org/) (DMs are always E2EE, group chats are only if you enable it), [Session](https://getsession.org/), [Signal](https://signal.org/), even Apple's [iMessage](https://www.apple.com/privacy/features#imessage) (the iCloud **backups** of your messages are [not E2EE](https://support.apple.com/en-gb/HT202303), unless you enable [Advanced Data Protection](https://support.apple.com/en-us/HT212520), otherwise it's completely E2EE between devices, meaning Apple cannot read them), but of course it's used for basically anything that requires very secure data storage. <br/>
Continuing with the Apple example, with Advanced Data Protection almost all of your iCloud data is stored using E2EE, so only you can access it. Point is: E2EE is not just for messages, it's just a way of encrypting any arbitary data, even if it's just for a single recipient (you).

# Cryptographic terms

Since this section is going to mention a lot of advanced cryptographic terms, I'd like to quickly mention some.
* [DH (Diffie-Hellman)](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange): The DH key exchange was [created in 1977](https://worldwide.espacenet.com/patent/search/family/025257633/publication/US4200770A?q=pn%3DUS4200770) by [Bailey Diffie](https://en.wikipedia.org/wiki/Whitfield_Diffie) and [Martin Hellman](https://en.wikipedia.org/wiki/Martin_Hellman), with some help from [Ralph Merkle](https://en.wikipedia.org/wiki/Ralph_Merkle). This post is not going to get into the mathematical details, but basically DH works by mixing a random private key you generate with the public key of the person you want to perform the key exchange. They do the same, but with their private key and your public key. (Note that the public and private keys are mathematically linked together, they aren't completely random)
* [Elliptic curve](https://en.wikipedia.org/wiki/Elliptic_curve): An elliptic curve is a mathematical algebraic curve, usually written in the form of $y^2 = x^3 + ax + b$, where a and b are random numbers. In cryptography, they're used for:
  * [Elliptic-curve cryptography (ECC)](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography): ECC is a type of [public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography) using the powers of elliptic curves. They're usually harder to break even with smaller key sizes, because of the [Elliptic Curve Discrete Logarithm Problem](https://link.springer.com/referenceworkentry/10.1007/978-1-4419-5906-5_246). If you don't understand any of this (I don't), then here is an [easy to understand video from Computerphile](https://www.youtube.com/watch?v=NF1pwjL9-DE).
  * [Elliptic-curve Diffie-Hellman (ECDH)](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman): ECDH is just the Diffie-Hellman key exchange, but with ellipctic curves. When the implementation mentions DH, ECDH is meant, since I'm going to use elliptic curves for everything anyway. Here, it's going to be used as part of the X3DH algorithm to perform the DH key exchanges.
  * [Elliptic Curve Digital Signature Algorithm (ECDSA)](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm): ECDSA is - similar to ECDH - a variant of the [Digital Signature Algorithm (DSA)](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm), using ellipctic curves. DSA is used to [digitally sign](https://en.wikipedia.org/wiki/Digital_signature) arbitary data using public and private keys ([asymmetric cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography)). I'm going to use it for the X3DH algorithm.
* [Hashing](https://en.wikipedia.org/wiki/Hash_function): Hashing is the process of turning any arbitary data into a fixed-length block. The length is defined by the hash algorithm, and is usually 256 bits (32 bytes). Hashes are mainly used for verifying data integrity, since even the slightest change (for example, replace a dot with a comma) has drastic impacts on the derived hash.
* [AES (sometimes called Rijndael)](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard): AES (Advanced Encryption Standard) is probably the most widely used [symmetric-key encryption algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm) (this means that the same key decrypts and encrypts the data, unlike in [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) for example). It's a variant of the Rijndael algorithm and works with a fixed key size of 128, 192 or 256 bits (16, 24 and 32 bytes respectively) and processes 128 bits (16 bytes) of data at a time, this is also called the block size. I'll use its variant called [AES-GCM](https://en.wikipedia.org/wiki/AES-GCM-SIV) with a 256 bits long key for the actual (en/de)cryption.
* [HKDF](https://en.wikipedia.org/wiki/HKDF): HKDF is a [key derivation function](https://en.wikipedia.org/wiki/Key_derivation_function) (which basically takes in some parameters and returns a cryptographically secure key, other examples are [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) and [Argon2](https://en.wikipedia.org/wiki/Argon2)) with some [HMAC](https://en.wikipedia.org/wiki/HMAC) sprinkled on top of it, to ensure integry and authenticity. It's going to be the main function I'll use for the Double Ratchet implementation, since it is essentially a ratchet function.
* [Forward secrecy](https://en.wikipedia.org/wiki/Forward_secrecy): forward secrecy (also called perfect forward secrecy) means that when a secret is revealed, it cannot be used to crack previous sessions or messages for example. Let's say I use a single key to encrypt all of my messages. In that case, if an attacker cracks the message once, they get access to all past and future messages.
* [Future secrecy (or backward secrecy)](https://users.ece.cmu.edu/~adrian/projects/sec/node6.html): future secrecy is the opposite of forward secrecy: when a secret is compromised, it cannot be used to crack future sessions. The previous example with the single key had no forward or future secrecy. If the key was replaced a ratchet function that uses key derivation functions to always generate new keys based on a starting key, cracking one key would mean you cannot crack previous keys, but it would still not have future secrecy, since you could input the compromised key into the ratchet and it'll generate all the future keys for you.

# Main concepts for E2EE

E2EE is basically made up of two parts: key exchange and encryption algorithm. For an E2EE algorithm to be secure, both parts must be robust and secure. A house with a super complicated, top-of-the-line security system, but with the deactivation key just being a simple button you need to press, wouldn't be too secure, right?

So let's take a look at these two parts:

## Key exchange

Since all encryption algorithms need some sort of secret key (a key that's meant to be kept secret and only known to a very few selected people, sometimes just you), you need to share it with the recipient, so they can actually understand and read your messages. There are a lot of different types of key exchange, the most secure being meeting with the recipient in person and sharing the key that way. But alas, we're stuck on the Internet, so we'll have to figure out a way to share keys with each other while assuming that the entire world is listening to us and trying to break the communication.

Luckily, smart people have already figured out some pretty good ways of doing that (proof: the URL of this website starts with `https://`), two of which we're going to discuss and implement later: the [Diffie-Hellman key exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange), and Signal's [Extended Triple Diffie-Hellman](https://www.signal.org/docs/specifications/x3dh/) key agreement protocol (X3DH), which is a beast and my personal favourite.

## Encryption algorithm
 
Great, you've shared a random secret key with your recipient, time to encrypt messages! So let's just put that key into an AES algorithm, and we're don- ***NO!!!***

See, AES is nice and all, but think about what happens if a hacker breaks the key: oops, they just got access to all past and future messages, my bad! This is where forward secrecy comes in handy, something I've already mentioned previously.<br/>
To implement this, we can use "ratchet" functions. These functions work like a real [ratchet](https://en.wikipedia.org/wiki/Ratchet_(device)): they only go forward, but not backwards. If you know what [hashing](https://en.wikipedia.org/wiki/Hash_function) is, you might recognise that it is also a ratchet function: you cannot revert a hash to get the original input data.

Alright, you've updated your app so it uses a ratchet function to generate a new key for each message, and this ratchet is syncronised on the recipient's and your devices (since otherwise they wouldn't be able to decrypt your messages). I think you can figure out the next problem: if hackers can't read past keys, can't they just use the ratchet to generate all future keys after compromising one? They can, you're absolutely correct. Solution: add another ratchet, 2 > 1!

I'm serious, an encryption algorithm we're going to cover in this post also comes from Signal, and it's called (wait for it...): [The Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/). Yeah, the creators weren't exactly creative with the name, but it works. The idea is that there is a main ratchet used to generate the encryption keys, and another ratchet which frequently refreshes the encryption ratchets using a DH or X3DH key exchange (so it becomes completely randomised and unpredictable), which means even if an attacker breaks one of your keys, they can only see a few more messages (depending on the implementation) before the encryption ratchet is refreshed again.
After your double ratchet system has been set up, you can finally use the generated encryption keys with any cipher you want. For the implementation, we're always going to use 256-bit AES-GCM.

# Implementing DH, XD3H and Double Ratchet

We're finally doing it! Get ready, because this is about to get heavy.
<Note>If you're only here for the explanation of how these systems work, you're in luck, the implementation also has explanation baked into it! :)</Note>

## Quick information

Before doing anything crazy, you should know some important stuff (you can change anything mentioned here, but these are what I'm going to make the example codes with).<br/>
For anything cryptography related, I'm going to use a browser API called [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API). This API contains a bunch of useful cryptographical functions that can be used to implement cryptographical stuff. (Logic Lv. 9999).

Unfortunately it has some caveats:
* Since it hasn't been approved yet as a [W3C standard](https://wicg.github.io/webcrypto-secure-curves/), safe curves e.g. [Curve25519](https://en.wikipedia.org/wiki/Curve25519) are not available. Why this matters will be explained below.
* Because of the lack of Curve25519, I'm going to use the [NIST P-256](https://neuromancer.sk/std/nist/P-256) curve instead. Yes, I know it's [not really secure](https://miracl.com/blog/backdoors-in-nist-elliptic-curves/), but it's only for the purposes of showcasing, feel free to use any custom library with stronger curves for anything I'm about to do.

So let's start!!!

## Implementing a basic DH key exchange

### Generating the keypairs

For a DH key exchange to happen, we need 2 things: Alice's and Bob's keypair. We can then mix the recipient's public key with our private key and get a shared secret.

<Warning>Make sure the following code is served from a server with https, because the Web Crypto API only works in secure contexts!</Warning>

```typescript
const crypto = window.crypto.subtle;
```

We declare a variable called "crypto", and set it to the Window's [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto) object. SubtleCrypto is part of the Web Crypto API and has all the cool stuff we want.

```typescript
const alice = await crypto.generateKey(
    { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey"]
);

const bob = await crypto.generateKey(
    { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey"]
);
```

This should be pretty self explanatory: we create two variables named `alice` and `bob` using the [`SubtleCrypto.generateKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey) method with the required parameters:
1. the algorithm we want to use: (ECDH with the [P-256](https://neuromancer.sk/std/nist/P-256) curve),
2. if we'd like to export the key later. If we set it to false, [`SubtleCrypto.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey) will not work on the keys, so we cannot store them later, which is usually not what you'd want.
3. An array of key usages. `deriveKey` means that we'll use this keypair later to create a new key.

```typescript
function toHex(buffer: ArrayBuffer) {
    return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

console.log(`Alice's private key: ${toHex(await crypto.exportKey("pkcs8", alice.privateKey))}, public key: ${toHex(await crypto.exportKey("raw", alice.publicKey))}`);
console.log(`Bob's private key: ${toHex(await crypto.exportKey("pkcs8", bob.privateKey))}, public key: ${toHex(await crypto.exportKey("raw", bob.publicKey))}`);
```

This is a bit more complicated. First, we define a new function called `toHex`, which takes in an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) object and turns it into its hex representation. We need this because right after it we're going to display the generated keys using [`SubtleCrypto.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey), which returns an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) object that we cannot just `console.log()`. So we first define a utility function that makes the keys human-readable. And then we actually export the keys and display them to the console. Notice how with private keys the type is set to `pkcs8`, while public keys use `raw`. This is just a [quirk of SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#supported_formats), you cannot use the raw format on private keys and the pkcs8 format on public and AES secret keys.

### Deriving the secret key

Time to do a DH key exchange!

```typescript
const aliceSecret = await crypto.deriveKey(
    { name: "ECDH", public: bob.publicKey }, alice.privateKey,
    { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
);

const bobSecret = await crypto.deriveKey(
    { name: "ECDH", public: alice.publicKey }, bob.privateKey,
    { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
);
```

Because we've previously set the key usage to `deriveKey`, we can use [`SubtleCrypto.deriveKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey) on the keypairs. First we define the algorithm, in this case "ECDH" with the public component, our private key, the type of key we want to generate (we'll use 256 bits long AES-GCM), and finally the already known export and key usage values. `encrypt` and `decrypt` mean exactly what you think: only keys with these usages are accepted in [`SubtleCrypto.encrypt()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt) and [`SubtleCrypto.decrypt()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt). <br/>
Notice how Alice uses Bob's public key and her private key, while Bob does the exact opposite. If all turns out fine, we should get the same exact keys, so let's check!

```typescript
console.log("Derived shared secrets!");

console.log(`Alice's secret: ${toHex(await crypto.exportKey("raw", aliceSecret))}`);
console.log(`Bob's secret: ${toHex(await crypto.exportKey("raw", bobSecret))}`);
```

`SubtleCrypto.exportKey()` - as the name suggests - turns a `CryptoKey` object into a format that we can then read/write, because you cannot just read a `CryptoKey` object (if you put it into `console.log()` it'd only tell you the key usages, if it's a secret or part of a keypair, the algorithm used to generate the key and if it's extractable). We also know what `toHex` does, so let's look at the results!

```
Generated keypairs!
Alice's private key: 308187020100301306072a8648ce3d020106082a8648ce3d030107046d306b0201010420635b42d1d8c4dd3dead643b50e6fe56bfbab071370c4e02c27b81b5273041439a1440342000428f4a66b3d11b597ff2ba2b0ec33fe87074e416e796b02579b474b455781b930f3879f637859e963de79c2fff5995568abd1dc92f4d09a8b5ead67a2f48d6307, public key: 0428f4a66b3d11b597ff2ba2b0ec33fe87074e416e796b02579b474b455781b930f3879f637859e963de79c2fff5995568abd1dc92f4d09a8b5ead67a2f48d6307
Bob's private key: 308187020100301306072a8648ce3d020106082a8648ce3d030107046d306b02010104201949cd99096254b9d90bd23aac8f4dde59c8a30253f7ba0f722fcc0cab797094a144034200047a16f4a6a7da34b387bd3c337fb7f1df40751f5df95184144a0e5f63fc62e313dc6d0d8e25602a9d224a7b208258c20b7085018ff12b0876972ff043d5bbfb85, public key: 047a16f4a6a7da34b387bd3c337fb7f1df40751f5df95184144a0e5f63fc62e313dc6d0d8e25602a9d224a7b208258c20b7085018ff12b0876972ff043d5bbfb85
Derived shared secrets!
Alice's secret: a49977f16b7ca79faedb98eac5abebabed687da2ccc4a27e63480afefb213a4c
Bob's secret: a49977f16b7ca79faedb98eac5abebabed687da2ccc4a27e63480afefb213a4c
```

They match, which means we've done a great job! We could now theoretically use this key to perform symmetric AES encryption, but I've already explained why a single key is a bad idea, so let's not do that yet.

### Actually, can I test some encryption?

For the third time, do not **ever** use a single key for encryption, but just to see how it works in `SubtleCrypto`, I'll show you how to use the generated secret from earlier to encrypt a simple "Hello World" message.

Since you've already set up the final secret keys with the `encrypt` and `decrypt` key usages, you just need to provide the [IV (initialization vector)](https://en.wikipedia.org/wiki/Initialization_vector) and the data to encrypt.

<Note>The initialization vector should be completely random every time you encrypt something. You also need to transmit it to the recipient, but it does not need to be kept secret.</Note>

```typescript
const data = new TextEncoder().encode("Hello, world!");

const iv = window.crypto.getRandomValues(new Uint8Array(16));
const encrypted = await crypto.encrypt({ name: "AES-GCM", iv }, aliceSecret, data);

console.log(`Encrypted data: ${toHex(encrypted)}`);
```

The [`TextEncoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder) class is used to convert the [`UTF-8`](https://en.wikipedia.org/wiki/UTF-8) string into a [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array). Then we define `iv` using the [`Crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) function, which does pretty much what it says: you provide it with a [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) (in this case, [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)), and it fills up every byte with a [random value](https://en.wikipedia.org/wiki/Random_number_generation). It is not a truly random number generator (TRNG), but a pseudorandom number generator (PRNG) with high enough entropy that is suitable for cryptographic purposes.

After the initial setup, you can run [`SubtleCrypto.encrypt()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt), with the specified algorithm, in this case `"AES-GCM"` which also needs the IV, the key to encrypt with and the actual data. This method returns an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), which is then hexified and logged to the console.

Let's see the result (it's going to be completely different for you)!

```
Encrypted data: 30c4c584523b6da399aec32504ff607d7e39f35b5e416383f270383bc9
```

Now let's do the very opposite:

```typescript
const decrypted = await crypto.decrypt({ name: "AES-GCM", iv }, aliceSecret, encrypted);

console.log(`Decrypted data: ${new TextDecoder().decode(decrypted)}`);
```

At this point you should be able to understand everything. As mentioned previously, AES uses the same key for en- and decryption, so you'll need to use `aliceSecret` (or `bobSecret`, since we know they're the same) again. [`TextDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder) is just the opposite of [`TextEncoder`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder): it turns any buffer source (in this case an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)) into `UTF-8`.

Result:

```
Decrypted data: Hello, world!
```

Congratulations, you just learned how to perform a basic DH key exchange between two parties and use the derived secret to encrypt some data.

Download the entire code for this example <a href="/files/double-ratchet.ts" download="double-ratchet.ts">here</a>.

### Hold up, wait a minute...

If you look really closely at this code, and I mean extremely closely, you might realise something: these keypairs are generated locally on the same exact device, in the same JS script. Obviously that makes no sense for an E2EE app, and you're right, you're supposed to transmit the public keys via the Internet, which raises a problem: how can I make sure the server is not messing with the public keys?

If you've ever used a platform like Matrix or Signal, you might have noticed that both have a verification system (Matrix uses emojis, Signal uses "safety numbers"). The verification panel also says that you're supposed to verify via a safe channel (so basically not the same app you want to verify in) that the same exact emojis/numbers are shown on both devices. This verification solves the problem described earlier: it verifies that the server is not trying to perform a [MITM](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) attack. Matrix uses [SAS (Short Authentication String)](https://matrix.org/docs/guides/implementing-more-advanced-e-2-ee-features-such-as-cross-signing#1-implement-emoji-verification-sas), which performs a DH key exchange described above, applies HKDF to the derived secret and converts the result into an emoji or number. That way, if the emojis don't match on both devices, you know that the server has **modified** at least one of the public keys during transit. The secret is then authenticated with [MAC](https://en.wikipedia.org/wiki/Message_authentication_code) (another type of digital signature, but it uses a single key instead of private and public keys), verified on both devices and the process ends. Signal on the other hand just generates a [safety number](https://signal.org/blog/safety-number-updates/) using your and the recipient's public key. The idea is the same: if the numbers don't match on both devices, the server is doing shady stuff.

## Implementing X3DH

DH is cool, but X3DH has X in its name, which makes it even cooler. So how about we upgrade our DH key exchange to its cooler brother?

### Initial setup

X3DH needs a bunch of [other keypairs](https://www.signal.org/docs/specifications/x3dh#keys) to work (we're going to use the P-256 curve for all of them). These key(pair)s include: identity key (this never changes), prekey (this can change depending on the implementation to provide forward-secrecy, we're not going to implement that here) and a list of one-time prekeys (these should all be discarded after they're used, and refreshed when their amount falls below a certain threshold, for this example we're going to generate 20 random keys and just choose one during the protocol run). The public prekey is signed with ECDSA, with the signing key being the private identity key (this means that the recipient can verify the digital signature with the public identity key).

Because there are going to be lot of key generations involved, let's simplify the setup process into a single function.

This example is going to get very big and complicated, so I'll try to comment the code to explain what some of the stuff means and to show what's happening on-device and on the server.

```typescript
const crypto = window.crypto.subtle;

interface X3DHObject {
    identityKeyPair: CryptoKeyPair; // Stored on server with the private key being protected (encrypted). Client may verify integrity of keys.
    preKeyPair: CryptoKeyPair; // Same as before.
    preKeySignature: ArrayBuffer; // Stored on server, client may verify integrity.
    onetimeKeys: Array<OneTimeKey>; // Same as before.
}

interface OneTimeKey {
    public: CryptoKey; // Public to everyone (including server).
    private: CryptoKey; // Protected from the server.
    id: number; // A random identifier, client may verify integrity, in case the server tries to alter it.
    used: boolean; // In a real-world implementation, the private keys would be stored safely on the device, and the second someone requests a one-time prekey, it's completely deleted from the server. This is only used here to make the code easier to understand, and just tells you if the key has been used.
}

function toHex(buffer: ArrayBuffer) {
    return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function setupX3DH(): Promise<X3DHObject> { // everything happens on device
    const identityKeyPair = await crypto.generateKey(
        { name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]
    );

    const preKeyPair = await crypto.generateKey(
        { name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]
    );
```

First we set up some interfaces for TypeScript. If you're implementing this in pure JavaScript, you can skip this step. Then we create the `toHex` function, which we've already used earlier. The `setupX3DH` function starts off easy: we generate the identity key and prekey. They're both using the P-256 curve with key usages set to `deriveBits`, because later we're going to use them to generate a byte sequence, not a new key (if it was `deriveKey`, we could only use to generate a new AES key for example, but X3DH expects a byte sequence, not a key). Note that `setupX3DH` is an async function, since we'll need to use `await` for `SubtleCrypto`'s functions.

<Warning>Indented lines are part of a function</Warning>

```typescript
    // setupX3DH
    const identitySigningKey = await crypto.importKey(
        "pkcs8", await crypto.exportKey("pkcs8", identityKeyPair.privateKey),
        { name: "ECDSA", namedCurve: "P-256" }, false, ["sign"]
    );

    const preKeySignature = await crypto.sign(
        { name: "ECDSA", hash: "SHA-512" }, identitySigningKey,
        await crypto.exportKey("raw", preKeyPair.publicKey)
    );
```

This is another quirk of `SubtleCrypto`. You cannot use a key generated with `ECDH` for the `ECDSA` algorithm, even though they're completely interchangable. So we're using this hack which exports the private identity key, then re-imports it with `ECDSA`, so we can use the `sign` key usage on it. Note that the exported key format is set to [`pkcs8`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8), since we're exporting a private key.

After the private identity key has been modified that `SubtleCrypto` can accept it, it is used by `SubtleCrypto.sign()` to create a digital signature of the public prekey, which only the public identity key can verify.

Next we'll set up 20 random one-time prekeys.

```typescript
    // setupX3DH
    const onetimeKeys = new Array<OneTimeKey>();

    for(let i = 0; i < 20; i++) {
        const keyPair = await crypto.generateKey(
            { name: "ECDH", namedCurve: "P-256" }, true, ["deriveKey"]
        )

        onetimeKeys.push({
            public: keyPair.publicKey,
            private: keyPair.privateKey,
            id: i,
            used: false
        });
    }

    console.log("X3DH setup complete.");

    return {
        identityKeyPair,
        preKeyPair,
        preKeySignature,
        onetimeKeys
    };
}
```

We create a new array called `onetimeKeys`, which we instantly populate with 20 completely random P-256 keys. The `id` can be a completely random number, but to avoid collisions, I just used a linearly increasing number, so they're all unique. Initially, `used` is set to `false`, this will change when a party initiates a protocol run. Finally, we finish the key generation by returning the identity key, prekey, the prekey signature and an array of 20 one-time prekeys.

### Fetching a prekey bundle

The next step is to start a protocol run. For this we'll of course use Alice and Bob. Assume that they've both already generated a X3DH object, and uploaded them to the server with the safety precautions mentioned earlier. Now let's see how would it look like if Alice wanted to create a shared secret with Bob using X3DH.

```typescript
interface PrekeyBundle {
    identityKey: CryptoKey; // the public identity key of the fetched user
    preKey: CryptoKey; // the public prekey of the fetched user
    preKeySignature: ArrayBuffer; // the signature of the prekey
    oneTimeKey: CryptoKey; // the public one-time prekey of the fetched user
    oneTimeID: number; // the ID of the one-time prekey
}

function getPrekeyBundle(user: X3DHObject): PrekeyBundle { // happens on server
    const oneTimeKey = user.onetimeKeys.filter(key => !key.used)?.[Math.floor(Math.random() * user.onetimeKeys.length)];
    if (oneTimeKey) user.onetimeKeys[user.onetimeKeys.indexOf(oneTimeKey)].used = true;

    return { // return as a response to a HTTP request or some other protocol
        identityKey: user.identityKeyPair.publicKey,
        preKey: user.preKeyPair.publicKey,
        preKeySignature: user.preKeySignature,
        oneTimeKey: oneTimeKey?.public ?? undefined,
        oneTimeID: oneTimeKey?.id ?? undefined
    }
}
```

We declare another utility interface for X3DH, then create a `getPrekeyBundle` function, which takes a `X3DHObject` as parameter. Note that all of the code inside this function is performed on the server, so it's not dependent on the other party's online status. As you could guess from the code, the one-time prekey might not exist, this could happen if too many users have tried to get a prekey bundle for a party, and the said party wasn't online to regenerate the one-time keys. The X3DH documention mentions that in this case the protocol may still be continued, but security will be reduced.

### Generating the secret key

Great, so Alice has fetched a prekey bundle of Bob and prepared her own private keys. This is where it gets complicated.

Basically, Alice first verifies that Bob's prekey is valid using the signature and his public key. If that succeedes, she creates a completely new ephemeral key, this will be used for this protocol run only (basically it's a one-time prekey, but for Alice). Then she needs to calculate 4 (3 if the one-time prekey is missing) DH exchanges:
1. DH1 = private identity key + public prekey
2. DH2 = private ephemeral key + public identity key
3. DH3 = private ephemeral key + public prekey
4. (DH4 = private ephemeral key + public one-time prekey)
   
Remember, all of these DH key exchanges will return a random sequence of bytes (in our implementation, they'll be 32 bytes long). To compress them into a single shared secret key, Alice concatenates all of these byte sequences together, then passes it to the HKDF algorithm.

The HKDF function needs a `salt` and `info` extra parameter, both can be public. The former will be a randomly generated 32-bytes long sequence, the latter just the UTF-8 encoding of "E2EE is amazing!" (this can be anything you'd like).

```typescript
interface X3DHRequest {
    identityKey: CryptoKey; // the public identity key of the user who requested a protocol run
    ephemeralKey: CryptoKey; // the public ephemeral key of the user
    oneTimeID: number; // the ID of the one-time key the user used
    ciphertext: Uint8Array; // the initial ciphertext
}

async function createX3DHRequest(user: X3DHObject, bundle: PrekeyBundle): Promise<X3DHRequest> { // happens on client
    // verify the prekey signature
    const identitySigningKey = await crypto.importKey(
        "raw", await crypto.exportKey("raw", bundle.identityKey),
        { name: "ECDSA", namedCurve: "P-256" }, false, ["verify"]
    );

    const verified = await crypto.verify(
        { name: "ECDSA", hash: "SHA-512" }, identitySigningKey,
        bundle.preKeySignature, await crypto.exportKey("raw", bundle.preKey)
    );

    if (!verified) throw new Error("Prekey signature invalid.");
```

We start by creating yet another interface for a X3DHRequest. This object will be used by Alice after she's derived the shared secret: she'll populate this object with the required data that Bob needs to calculate the same secret. Then, we define an async function called `createX3DHRequest`, which takes in the user and prekey bundle. Note that everything in this function happens on the device.

We do the weird export-import hack (note that we're using type `raw` here, because `bundle.identityKey` is a public key!), but this time on the public identity key. If this was real code, the keys would be transmitted with a Base64, hex etc. encoding, so you wouldn't need this SubtleCrypto mess, you only have to do this if you're trying to use an already existing `CryptoKey` object. Then it is used to verify the prekey signature. If it fails, the protocol run is instantly aborted.

```typescript
    // createX3DHRequest
    // derive the shared secret
    const ephemeralKey = await crypto.generateKey(
        { name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]
    );

    // generate the 4 DH values
    const DH1 = await crypto.deriveBits(
        { name: "ECDH", public: bundle.preKey }, user.identityKeyPair.privateKey, 256);
    const DH2 = await crypto.deriveBits(
        { name: "ECDH", public: bundle.identityKey }, ephemeralKey.privateKey, 256);
    const DH3 = await crypto.deriveBits(
        { name: "ECDH", public: bundle.preKey }, ephemeralKey.privateKey, 256);
    const DH4 = bundle.oneTimeKey ? await crypto.deriveBits(
        { name: "ECDH", public: bundle.oneTimeKey }, ephemeralKey.privateKey, 256) : undefined;

    // concatenate the DH values
    const DH = new Uint8Array(bundle.oneTimeKey ? 128 : 96);
    DH.set(new Uint8Array(DH1), 0);
    DH.set(new Uint8Array(DH2), 32);
    DH.set(new Uint8Array(DH3), 64);
    if (bundle.oneTimeKey) DH.set(new Uint8Array(DH4), 96);
```

After verifying the prekey signature, we generate a new ephemeral key (key usage set to `deriveBits` again), then perform the 4 DH key exchanges, each time setting the length to the maximal 256, to indicate we want the result to be 32 bytes long (because 256 bits = 32 bytes). `DH4` is set to undefined if the one-time prekey doesn't exist. Then, these 4 DH results are concatenated together into a single Uint8Array, which can either be 128 or 96 bytes long, depending on the one-time prekey again.

```typescript
    // createX3DHRequest
    // derive the secret key
    const info = new TextEncoder().encode("E2EE is amazing!");

    const secretKeyInput = await crypto.importKey(
        "raw", DH, "HKDF", false, ["deriveKey"]
    );

    const secretKey = await crypto.deriveKey(
        { name: "HKDF", salt: new Uint8Array([0]), info, hash: "SHA-512" }, secretKeyInput,
        { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
    );

    console.log(`Secret key derived: ${await crypto.digest("SHA-256", await crypto.exportKey("raw", secretKey))}`);
```

At the end, we import our byte sequence and set its algorithm to `HKDF` and key usage to `deriveKey` (since we're going to derive a key in the next step), and finally perform `SubtleCrypto.deriveKey()` to turn our input key material into a AES key we can use. The salt is just a single 0 byte, which fortunately doesn't compromise security. For debugging purposes, I logged the [SHA-256](https://en.wikipedia.org/wiki/SHA-2) result to the console, but for obvious reasons do not ever do this in production code, even if it's a hash.

### Constructing the request object

We're not done yet though, we'll also need to generate a request object for Bob, so he can also perform the calculations we've done earlier. Fortunately this is really simple.

```typescript
    // createX3DHRequest
    // generate AD (concatenate the hash of the two public identity keys)
    const AD = new Uint8Array(64);
    AD.set(new Uint8Array(await crypto.digest("SHA-256", await crypto.exportKey("raw", user.identityKeyPair.publicKey))), 0);
    AD.set(new Uint8Array(await crypto.digest("SHA-256", await crypto.exportKey("raw", bundle.identityKey))), 32);

    // create the initial ciphertext
    const iv = window.crypto.getRandomValues(new Uint8Array(16));
    const message = new TextEncoder().encode(JSON.stringify({
        identityKey: toHex(await crypto.exportKey("raw", user.identityKeyPair.publicKey)),
        ephemeralKey: toHex(await crypto.exportKey("raw", ephemeralKey.publicKey)),
        oneTimeID: bundle.oneTimeID
    }));
```

First we create an AD (associated data) by hashing the requesting user's public key and the requested user's public key and concatenating them together (we use their hash to make sure they're exactly 32 bytes long). The requested user has to reconstruct this to be able to read the initial ciphertext. <br/>
A new IV is also generated along with the plaintext of the initial ciphertext. What this message contains is completely up to the application, but my implementation has the keys transmitted in plaintext stored here too, so in case the server tries to mess with the keys, the message will contain completely different ones, which can be used to verify the integrity of a X3DH request.

```typescript
    // createX3DHRequest
    const ciphertextBase = await crypto.encrypt(
        { name: "AES-GCM", iv, additionalData: AD }, secretKey, message
    );

    // concatenate the iv and ciphertext
    const ciphertext = new Uint8Array(16 + ciphertextBase.byteLength);
    ciphertext.set(iv, 0);
    ciphertext.set(new Uint8Array(ciphertextBase), 16);

    // the secret key is discarded after this point, but in a real implementation it may be stored
    return {
        identityKey: user.identityKeyPair.publicKey,
        ephemeralKey: ephemeralKey.publicKey,
        oneTimeID: bundle.oneTimeID ?? undefined,
        ciphertext
    }
}
```

Finally we use `SubtleCrypto.encrypt()` on the message (note that there is another parameter added to the AES function, namely `additionalData`), create a new variable called `ciphertext` which is a concatenation of the iv and the encrypted message, then return the request object. This object contains all the keys Bob needs for the calculation of the secret key: the public ephemeral key, public identity key and the ID of the one-time prekey, all in plaintext (!). The ciphertext is encoded in Base64, and the function returns. Alice can now send the request object to Bob, who does the final calculations and finally ends the X3DH run.

### Accepting the request object

So now Alice has uploaded her request object to the server, which (hopefully) forwarded it to the now online Bob. Let's see what he has to do.

Because we don't have to verify our own prekey's signature, accepting the request simplifies a lot, and we can get straight to calculating the 4 DH values. Remember, the public keys Alice has used now became the private keys of Bob and vice versa. So the calculations change to the following:
1. DH1 = public identity key + private prekey
2. DH2 = public ephemeral key + private identity key
3. DH3 = public ephemeral key + private prekey
4. (DH4 = public ephemeral key + private one-time prekey)

```typescript
async function acceptX3DHRequest(user: X3DHObject, request: X3DHRequest) { // happens on device
    // calculate the DH values
    const DH1 = await crypto.deriveBits(
        { name: "ECDH", public: request.identityKey }, user.preKeyPair.privateKey, 256);
    const DH2 = await crypto.deriveBits(
        { name: "ECDH", public: request.ephemeralKey }, user.identityKeyPair.privateKey, 256);
    const DH3 = await crypto.deriveBits(
        { name: "ECDH", public: request.ephemeralKey }, user.preKeyPair.privateKey, 256);
    const DH4 = request.oneTimeID ? await crypto.deriveBits(
        { name: "ECDH", public: request.ephemeralKey },
        user.onetimeKeys.find(key => key.id === request.oneTimeID).private, 256) : undefined;

    // concatenate the DH values
    const DH = new Uint8Array(request.oneTimeID ? 128 : 96);
    DH.set(new Uint8Array(DH1), 0);
    DH.set(new Uint8Array(DH2), 32);
    DH.set(new Uint8Array(DH3), 64);
    if (request.oneTimeID) DH.set(new Uint8Array(DH4), 96);
```

If you've done everything correctly, the resulting `DH` buffer ***should*** have the same exact values as the one Alice generated. In that case, the HKDF will create the same key:

```typescript
    // acceptX3DHRequest
    // derive the secret key
    const info = new TextEncoder().encode("E2EE is amazing!");

    const secretKeyInput = await crypto.importKey(
        "raw", DH, "HKDF", false, ["deriveKey"]
    );

    const secretKey = await crypto.deriveKey(
        { name: "HKDF", salt: new Uint8Array([0]), info, hash: "SHA-512" }, secretKeyInput,
        { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
    );

    console.log(`Secret key derived: ${await crypto.digest("SHA-256", await crypto.exportKey("raw", secretKey))}`);
```

As you can see, this code is basically the same thing as the `generateX3DH` function, the only exception is that the salt is not randomly generated, it's in the `request` object. Also, because the `info` parameter is always a constant, we don't have to include it in the request, you can just generate it again. Anyway, let's finish up this code and test it for good!

```typescript
    // acceptX3DHRequest
    // generate AD (concatenate the hash of the two public identity keys)
    const AD = new Uint8Array(64);
    AD.set(new Uint8Array(await crypto.digest("SHA-256", await crypto.exportKey("raw", request.identityKey))), 0);
    AD.set(new Uint8Array(await crypto.digest("SHA-256", await crypto.exportKey("raw", user.identityKeyPair.publicKey))), 32);

    // extract the iv and ciphertext
    const iv = request.ciphertext.slice(0, 16);
    const ciphertext = request.ciphertext.slice(16);

    // decipher the ciphertext
    const message = await crypto.decrypt(
        { name: "AES-GCM", iv, additionalData: AD }, secretKey,
        ciphertext
    );

    console.log(`Deciphered message: ${new TextDecoder().decode(message)}`);
}
```

First we need to reconstruct the AD. Note that it's **Alice's** + **Bob's** public identity key, not the other way around! After that we extract the iv and ciphertext with the `Uint8Array.slice()` method and perform the final `SubtleCrypto.decrypt()` function using the secret key we've derived earlier with X3DH. If we've done everything correctly, it should decrypt without an error and we can print the decoded message to the console.

Anyway, I'm sure you're eager to finally test this code, so let's perform our first X3DH protocol run!

```typescript
// create Alice and Bob (happens on their devices)
const alice = await setupX3DH();
const bob = await setupX3DH();

// keys are uploaded to server, with private keys secured in some way (they could also be stored only on the device)

// Alice fetches Bob's bundle (response comes from server)
const bobBundle = await getPrekeyBundle(bob);

// Alice creates a request (happens on device, then sent to server)
const aliceRequest = await createX3DHRequest(alice, bobBundle);

// Bob accepts the request (happens on device)
await acceptX3DHRequest(bob, aliceRequest);
```

Output of the console:
```
X3DH setup complete.
X3DH setup complete.
Secret key derived: 7dbfad7f7730f7acbb5f702148e9f95a6b462bcf623732db47e38ac61dcd9f1f
Secret key derived: 7dbfad7f7730f7acbb5f702148e9f95a6b462bcf623732db47e38ac61dcd9f1f
Deciphered message: {"identityKey":"04277c29172c8b193a8a11a657efd49117de0c4ca5cf5313780d5b54ef5df1a949ee918d84b0902be80f9bc60ceb9902e7efe35889cac9c994f70992a8edeaeb4a","ephemeralKey":"04267f2986140ffe0cdaf29dd2a284c2e0a733617530abf428cc4cb9913927029b0745ad6dbbd033180e7b0b9b1d50c1d3b7f03afa18e97eb24db8b4637bb8e1d2","oneTimeID":11}
```

Congratulations, you've successfully learned how to implement the X3DH key exchange protocol using `SubtleCrypto`. Go and show this to your friends or something.

The code for this example can be downloaded <a href="/files/x3dh-example.ts" download="x3dh-example.ts">here</a>.

## Implementing Double Ratchet for 1-on-1 communication (final boss, beware!)

You've finally reached this. Well, this is the point of no return, if you decide to continue, you can never go back. <br/>
With that out of the way, let's do this! :)

### Creating a single ratchet

Obviously if you want to have a *double* ratchet, you'll logically need a *single* ratchet first.

There are actually a lot of different ways to create a ratchet. After all, it really just needs a function that can "turn" one way, but never in the other. We will use HKDF, a type of key derivation function supercharged by HMAC.

<Note>HMAC is basically a version of MAC that also uses a hash function.</Note>

This single ratchet will take in an initial key as its state, and provide a function to perform a turn. When the ratchet is turned, the ratchet's state is fed into the HKDF algorithm with some constants and we get a new key. We split this key in half, the first part is going to be the new state and the second half is what we actually use for message encryption/decryption. This is also called a symmetric ratchet, because it just keeps feeding a state into itself, there are no other parameters that would change the output. Later we'll create a DH ratchet which will no longer be symmteric, since it uses a combination of different inputs.

```typescript
const crypto = window.crypto.subtle;

// global hkdf info constant, can be anything
const hkdfInfo = new TextEncoder().encode("Created by Mester");

function toHex(buffer: ArrayBuffer) {
    return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

/** 
 * A single symmetric ratchet that can turn and return a message key
 */
class SymRatchet {
    // set the state to a private member, so it cannot be accessed from outside
    #state: Uint8Array = new Uint8Array();

    constructor(seed: Uint8Array) {
        if (seed.byteLength !== 32) throw new Error("Invalid seed length");
        this.#state = seed;
    }

    async turn() {
        const state = await crypto.importKey("raw", this.#state, "HKDF", false, ["deriveBits"]);

        // create a new state, the salt is just a single 0 byte
        const newState = await crypto.deriveBits({ name: "HKDF", hash: "SHA-512", salt: new Uint8Array([0]), info: hkdfInfo }, state, 64 * 8);

        // set the state to the first 32 bytes
        this.#state = new Uint8Array(newState, 0, 32);

        // return the last 32 bytes (used for message encryption/decryption)
        return new Uint8Array(newState, 32, 32);
    }
}
```

<Note>The # symbol in #state marks it as a private member which cannot be accessed outside the class</Note>

There is a lot to unpack here (fortunately the comments help explain a lot).

We define a global `hkdfInfo` variable, this is a constant used for the HKDF algorithm (it was already used once in the X3DH protocol). Then, a class called `SymRatchet` is created, this will server as our symmetric ratchet. It has a constructor which just sets the private state to the initial `Uint8Array` seed its given.

The `turn` function does multiple things:
1. Creates a random `Uint8Array` that holds a single 0 byte, this serves as the salt for HKDF. If a random salt was given for every turn, it'd get out of sync with our chat partner, since they don't know this random salt we generated.
2. We import the state as a `CryptoKey`, which is marked to be used in the `HKDF` algorithm for deriving bits. `SubtleCrypto.deriveBits()` works like `SubtleCrypto.deriveKey()` but it returns raw bytes instead of a `CryptoKey`.
3. The state key is then used to derive 64 bytes (512 bits) using HKDF. The `SHA-512` hash algorithm is used, because it generates a 64 bytes hash, so it's the most compatible with our ratchet.
4. The first 32 bytes become the state key and we return the rest.

Because only the first 32 bytes are used to perform a next turn, the data the `turn` function returns (also called the message key) can be stored, since it cannot be used to break into the ratchet. The preservation of message keys are not part of this post.

To test if it works, let's set up two ratchets, but with different starting seeds.

#### Example 1
```typescript
const ratchet = new SymRatchet(new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]));
for(let i = 0; i < 5; i ++) console.log(toHex(await ratchet.turn()));
```

Output:
```
e67b48f096bdebb50e0ae6ea1e37c9ec128bbc37424d27a87f3ef3697d00b1b6
38c1319aa2caca2f17000f99129ad98c44ac82fcc9402a817e790d06757c7e1f
3448baae021ed6066f3592c531101c31bf251ff1a11689f92dc38cb5fbc29137
ba98c268b3518dddb107d080f6e98963b71d28c1191ae6fbc7e21ebcd2b6bccc
685fe809a71a210a18bb01347607d639b747a742736ecd62bad7d1eeab22c2a0
```

#### Example 2
```typescript
const ratchet = new SymRatchet(new Uint8Array([31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]));
for (let i = 0; i < 5; i++) console.log(toHex(await ratchet.turn()));
```

Output:
```
1851171a68bea0f961ec8ed4b930059c2de32c2b4c8397cac2b2b739b9fffa82
af5a2f888e74a3c614816b677744d902cebbc3ba0e32e851c44cdaf7fa388c97
756cef3a87d542a95e9f1db20297897eb234ec86adaa23e8aac8870d8543aba2
290f0e96953281c5a6c333975d35985e5035f815da78cbae8afdc93782e33ee1
4dbc392fbc40af14fd9a51310ef8fd2cf87a433e1b2b3ed40999444748dc941a
```

As you can see, a relatively minor change of the seed (just reversing it) had huge impacts on the output keys. Yay, encryption!

### Creating the double ratchet

Great, now let's put two of these together to create a double ratchet. But wait... how exactly do we use these message keys?

Basically, we need to somehow create ratchets for Alice and Bob that are syncronised with each other (= their seed are the same). That way, if Alice encrypts a message, Bob will be able to read it, because he can generate the same exact key Alice used to encrypt a message. So both of them will get a send and receive ratchet: Alice's send ratchet is the same as Bob's receive ratchet and vice versa. So sending a message would look like this:
1. Alice turns her send ratchet, uses key to encrypt message.
2. Sends message to Bob.
3. Bob turns his receive ratchet, uses key to decrypt message.
4. Party 

To manage these ratchets, Alice and Bob will both create a root ratchet using a shared secret key (which can come from the previously implemented X3DH protocol). These keys are the basic single ratchets we created earlier, but this time, their output will be used to create new ratchets instead of encrypting messages.

There is something important to remember: if Alice and Bob create their root ratchets (which will produce the same keys!), and turn them once to create their send ratchets, then the send ratchets will be syncronised, which is not what we want. So in a real-world app, there has to be a system that decides who should use their root ratchet's first turn as their send ratchet and who should use it as their receive ratchet. In this implementation, we'll just include a boolean parameter in a class constructur, but a live code should figure it out automatically.

```typescript
/**
 * a double ratchet that can encrypt and decrypt messages
 */
class DoubleRatchet {
    #root: SymRatchet;
    #send: SymRatchet;
    #receive: SymRatchet;

    firstSend: boolean = true;

    constructor(seed: Uint8Array, firstSend: boolean = true) {
        this.#root = new SymRatchet(seed);

        this.firstSend = firstSend;
    }

    async init() {
        if(this.firstSend) {
            this.#send = new SymRatchet(await this.#root.turn());
            this.#receive = new SymRatchet(await this.#root.turn());
        } else {
            this.#receive = new SymRatchet(await this.#root.turn());
            this.#send = new SymRatchet(await this.#root.turn());
        }
    }

    async encrypt(message: ArrayBuffer) {
        // generate random IV
        const iv = window.crypto.getRandomValues(new Uint8Array(12));

        // turn the send ratchet to create a message key
        const messageKey = await crypto.importKey("raw", await this.#send.turn(), { name: "AES-GCM", }, false, ["encrypt"]);
        const ciphertext = await crypto.encrypt({ name: "AES-GCM", iv }, messageKey, message);

        return { iv, ciphertext };
    }

    async decrypt(ciphertext: ArrayBuffer, iv: ArrayBuffer) {
        // turn the receive ratchet to create a message key
        const messageKey = await crypto.importKey("raw", await this.#receive.turn(), { name: "AES-GCM", }, false, ["decrypt"]);
        const message = await crypto.decrypt({ name: "AES-GCM", iv }, messageKey, ciphertext);

        return message;
    }
}
```

That's basically it, although we haven't implemented the turning mechanism of the root ratchets yet. So let's take a look:

* The `init` function of the `DoubleRatchet` class is used to create the send and receive ratchets (the order is based on the previously mentioned `firstSend` boolean).
* `encrypt` takes in some bytes, generates a 12 bytes initialization vector and encrypts it with the message key from the send ratchet.
* `decrypt` does this in reverse, and turns the receive ratchet instead.

Now let's see if we can use it to send some messages between Alice and Bob! To make the secret sharing simpler, we'll just generate a random secret on the fly instead of using the X3DH code from earlier.

```typescript
const secret = window.crypto.getRandomValues(new Uint8Array(32));

const alice = new DoubleRatchet(secret);
const bob = new DoubleRatchet(secret, false);

await alice.init();
await bob.init();

const message = new TextEncoder().encode("Hello, Bob!");
let { iv, ciphertext } = await alice.encrypt(message);

console.log("Alice sends:", toHex(iv), toHex(ciphertext));

let decrypted = await bob.decrypt(ciphertext, iv);

console.log("Bob receives:", new TextDecoder().decode(decrypted));

const message2 = new TextEncoder().encode("Hello, Alice!");
// the parentheses around the assignment are necessary, otherwise it will be interpreted as a block
({ iv, ciphertext } = await bob.encrypt(message2));

console.log("Bob sends:", toHex(iv), toHex(ciphertext));

decrypted = await alice.decrypt(ciphertext, iv);

console.log("Alice receives:", new TextDecoder().decode(decrypted));
```

Output (will be different every time you run the script, since the secret is random):
```
Alice sends: 7e899e4fa28adbff971c3bf0 dc90e5c268b0c9916501cd6ba4842d4f81ae7fdb06940afd0371e5
Bob receives: Hello, Bob!
Bob sends: 195567797a43afcb9aab6039 e44970b853800a74004da171d26ccf93527883a8662f841b1961b45af3
Alice receives: Hello, Alice!
```

### Updating the double ratchet

If you've read everything in this post carefully, you might realise something: the ratchets as of right now don't provide future secrecy. Sure, the message keys cannot be used to break in, but what if someone cracks a ratchet state key? Then the attacker can (and probably will) use that state key to get all future keys. Fortunately they cannot go backwards, but even if a 2 days-old key is cracked, all the messages that are younger than 2 days are cracked too, and that is bad - don't forget the attacker can just keep turning his own compromised ratchet, so it might take you months or years to figure out you've been spied on all the time.

To fix that, we'll use the root ratchets to generate new send and receive ratchets after a certain limit has passed (the most secure option is after every single message). This however, does not solve our problems on their own, since right now the root ratchet is just a simple ratchet which has the same exact problems as the send and receive ratchets. So to truly make it recover from break-in attacks, instead of turning it the "conventional" way, we'll just refresh it with completely new, random DH keys.

For that to work though, we'll need to change the code a little, because our root ratchet is just a simple symmetric ratchet, like the send and receive ones. We want the root ratchet to be a Diffie-Hellman ratchet, which will provide us future secrecy (and happiness). Under the hood, it'll act similarly to a symmetric ratchet, but instead of the salt being a single 0 byte, we'll use the output of DH key exchanges as the HKDF salt.

Hold up... so how does it work?

Let's say Alice wants to chat with Bob. She generates a DH keypair and sends a message request to Bob, which contains a random seed for the root ratchet and her public key. Now Alice needs to wait for a response from Bob. Until that happens, all messages she tries to send must be put into a queue (or discarded completely). When Bob sees the request, he generates his own DH keypair and turns his root ratchet: he calculates the DH output of his private key and Alice's public key to generate a DH output, which will be the salt inside a symmteric ratchet (this randomises the output, providing future secrecy). The output of the symmteric ratchet will be used as the seed for his send ratchet. Now, Bob can send back his public key, and because he already has a send ratchet, he can already start sending messages to Alice, even if she's offline at the time.

When Alice sees Bob has accepted the message request and provided his own public ratchet, she can do a root ratchet turn too: because we know Bob has used the public key of Alice's first DH keychain, Alice can use his private key and Bob's public key to generate the same DH output for her symmetric ratchet. This output will be used to create Alice's receive ratchet which will be equal to Bob's send ratchet (she can read Bob's messages that he sent earlier with it). She now needs a send ratchet, so she generates a new DH keychain (discarding the old one) and uses the same public key she got from Bob to generate her send ratchet. Then she sends it to Bob.

Now, if Bob gets Alice's public key, the whole cycle repeats: Bob generates a receive ratchet, and a send ratchet with a new DH keypair, then sends his public key to Alice. Here, it's important to note: **A party can only turn their root ratchet, if they have received a new public key from the other party.** In other words, after Alice generates her receive and send ratchet, she cannot generate a new send ratchet again, because Bob has not yet received her public key and returned a new public key of his own. This is important to keep in mind, otherwise it could lead to desyncronisation of the root ratchets. Also, after the initial setup (which happens when Bob receives Alice's message request), every time a party turns their root ratchet, they must do it twice to generate a new send and receive ratchet.

<Note>Every message contains the party's public key (this will be used later for out-of-order messages), so the other party must decide if that key is new or not. This is not needed in the examples below, since we control the root turning manually, but in an actual application, this check should be automated.</Note>

If you didn't understand any of that, don't worry, me neither. I basically just turned the images [here](https://signal.org/docs/specifications/doubleratchet/#diffie-hellman-ratchet) to text.

So let's code.

```typescript
/**
 * A Diffie-Hellman ratchet used to provide future secrecy
 */
class DHRatchet {
    #state: Uint8Array = new Uint8Array();
    #keyChain: CryptoKeyPair;

    async init(seed: Uint8Array) {
        if (seed.byteLength !== 32) throw new Error("Invalid seed length");
        this.#state = seed;

        // generate a key pair
        this.#keyChain = await crypto.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]);
    }

    async init() {
        // generate a key pair
        this.#keyChain = await crypto.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]);
    }

    getPubkey() {
        return crypto.exportKey("raw", this.#keyChain.publicKey);
    }

    async turn(pubkey: ArrayBuffer, newKey: boolean = false) {
        // if needed, generate a new key pair
        if (newKey) {
            this.#keyChain = await crypto.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]);
        }

        // import the public key
        const publicKey = await crypto.importKey("raw", pubkey, { name: "ECDH", namedCurve: "P-256" }, false, []);

        // derive a new DH output
        const dhOutput = await crypto.deriveBits({ name: "ECDH", public: publicKey }, this.#keyChain.privateKey, 32 * 8);

        // use the DH output as the HKDF salt
        const state = await crypto.importKey("raw", this.#state, { name: "HKDF" }, false, ["deriveBits"]);
        const newState = await crypto.deriveBits({ name: "HKDF", hash: "SHA-512", salt: dhOutput, info: hkdfInfo }, state, 64 * 8);

        // set the state to the first 32 bytes and the final output to the last 32 bytes
        this.#state = new Uint8Array(newState, 0, 32);
        const final = new Uint8Array(newState, 32, 32);

        return final;
    }

    static async build(seed: Uint8Array) {
        const dr = new DHRatchet();
        await dr.init(seed);

        return dr;
    }
}
```

That's basically it! We create a `DHRatchet` class which has a private keyChain and state property, a function to set up the keychain, a function to get the public component of the keychain and our `turn` function, which requires a public key and a boolean that tells it if it's time to generate a new key. The `turn` function is almost identical to the one in the symmetric ratchet, but instead of the salt just being a bunch of 0s, it's actually the DH output now. In practice, you'd also implement a function that could save the private key component, but it must be done securely, although losing it doesn't cause much damage. There is also a static `build` function to help us create a DH ratchet easier.

We also need to change how our `DoubleRatchet` class works, since the root ratchet is not a simple symmetric ratchet anymore.

```typescript
class DoubleRatchet {
    root: DHRatchet;

    ...

    // firstSend property removed

    constructor() {
        this.root = new DHRatchet();
    }

    // init function removed

    async setup(ratchet: "send" | "receive", pubkey: ArrayBuffer, newKey: boolean = false) {
        const dhOutput = await this.root.turn(pubkey, newKey);

        if (ratchet === "send") this.#send = new SymRatchet(dhOutput);
        else this.#receive = new SymRatchet(dhOutput);
    }

    ...

    static async build(seed: Uint8Array) {
        const dr = new DoubleRatchet();
        dr.root = await DHRatchet.build(seed);

        return dr;
    }
}
```

This is what has changed:
1. The root ratchet is not a private member anymore, so its functions are more easily accessbile (this does not compromise security, since the keychain of the root ratchet is still private).
2. firstSend has been removed.
3. The constructor doesn't need a seed anymore and the root ratchet has been replaced by a DH ratchet.
4. Replacing the `init` function, a new `setup` function has been added, which needs the ratchet you're setting up (from the perspective of the root ratchet) and the rest of the parameters of the DH ratchet's `turn` function.
5. The `DoubleRatchet` class has now got a static `build` function to help initialisation easier.

So can we use it? Sure!

#### Alice and Bob send 1 message after each other

```typescript
const seed = window.crypto.getRandomValues(new Uint8Array(32));

const alice = await DoubleRatchet.build(seed);
const bob = await DoubleRatchet.build(seed);

// setup the ratchets
// Alice sends her public key to Bob
await bob.setup("send", await alice.root.getPubkey());
// Bob sends his public key to Alice
await alice.setup("receive", await bob.root.getPubkey());
await alice.setup("send", await bob.root.getPubkey(), true);

// encrypt a message (message contains Alice's new public key)
const message = new TextEncoder().encode("Hello Bob!");
let { iv, ciphertext } = await alice.encrypt(message);

console.log("Alice sends:", toHex(ciphertext), toHex(iv));

// Bob receives Alice's public key
await bob.setup("receive", await alice.root.getPubkey());
await bob.setup("send", await alice.root.getPubkey(), true);

// decrypt the message
let decrypted = await bob.decrypt(ciphertext, iv);

console.log("Bob receives:", new TextDecoder().decode(decrypted));

// encrypt a message (contains Bob's new public key)
const message2 = new TextEncoder().encode("Hello Alice!");
({ iv, ciphertext } = await bob.encrypt(message2));

console.log("Bob sends:", toHex(ciphertext), toHex(iv));

// Alice receives Bob's public key
await alice.setup("receive", await bob.root.getPubkey());
await alice.setup("send", await bob.root.getPubkey(), true);

// decrypt the message
decrypted = await alice.decrypt(ciphertext, iv);

console.log("Alice receives:", new TextDecoder().decode(decrypted));
```

Output:
```
Alice sends: 988c7a13a3b58955f4ba05de12fcad6a80d366b6c1366b51ed6c f6e8d92aa06475e9cd7fc59c
Bob receives: Hello Bob!
Bob sends: 4bb1ec908d0922f0f3f18c33067645297735a8525313ec98698e7d14 4c1a0d9f46ccda19363280ce
Alice receives: Hello Alice!
```

So that's basically how it works: the messages contain the party's public key which the other party can use to turn their root ratchet. 

#### Alice sends 2 messages

In the previous example, Alice and Bob both sent one message after each other, but that's not usually a case. Let's see what happens when Alice wants to send 2 messages.

```typescript
... // ratchet setup same as before

// Bob is offline

const message = new TextEncoder().encode("Hello Bob!");
let { iv: iv1, ciphertext: ciphertext1 } = await alice.encrypt(message);
console.log("Alice sends:", toHex(ciphertext1), toHex(iv1));

// Alice cannot turn the send ratchet again, we don't know Bob's new public key yet

const message2 = new TextEncoder().encode("Come on Bob, reply!");
let { iv: iv2, ciphertext: ciphertext2 } = await alice.encrypt(message2);
console.log("Alice sends:", toHex(ciphertext2), toHex(iv2));

// Bob is back online and has received the messages with Alice's new public key
await bob.setup("receive", await alice.root.getPubkey());
await bob.setup("send", await alice.root.getPubkey(), true);

const decrypted1 = await bob.decrypt(ciphertext1, iv1);
console.log("Bob receives:", new TextDecoder().decode(decrypted1));
const decrypted2 = await bob.decrypt(ciphertext2, iv2);
console.log("Bob receives:", new TextDecoder().decode(decrypted2));
```

Output:
```
Alice sends: 604e647a8bb4f61e9aa7a27803edf88ef15c2eef780a89ec36b5 79c2dfef93f91045a998ced5
Alice sends: 002c5604f5142994085466c444d501eede203e18a156da5b021147129d1d42c1d6f256 ed4834780375a84a0429e43f
Bob receives: Hello Bob!
Bob receives: Come on Bob, reply!
```

Because Alice has already used Bob's public key for turning her root ratchet, she cannot do that again with the same public key, therefore Alice must wait until Bob sends her his new public key. But that's no problem, because Alice can just turn her send ratchet to encrypt another message, and when Bob receives both messages, he turns his root ratchet to generate a new receive ratchet and can then decrypt both messages.


#### Bob sends a message first

In our examples, Alice was always the first to send a message, but obviously that might not always be the case. The code still works of course if Bob sends a message first, it's even simpler in that case!

```typescript
... // ratchet setup code same

// Bob has already used Alice's public key for setting up his send ratchet, so he cannot turn his root ratchet again
const message = new TextEncoder().encode("first");
let { iv, ciphertext } = await bob.encrypt(message);
console.log("Bob sends:", toHex(ciphertext), toHex(iv));

// Bob sends the message and his public key

// Alice decrypts the message
let decrypted = await alice.decrypt(ciphertext, iv);
console.log("Alice receives:", new TextDecoder().decode(decrypted));

// Bob hasn't created a new DH keypair, so Alice does not turn her root ratchet again
const message2 = new TextEncoder().encode("second");
({ iv, ciphertext } = await alice.encrypt(message2));
console.log("Alice sends:", toHex(ciphertext), toHex(iv));

// Alice sends the message and her public key

// Bob has not received Alice's public key yet, so he turns his root ratchet
await bob.setup("receive", await alice.root.getPubkey());
await bob.setup("send", await alice.root.getPubkey(), true);

// Bob decrypts the message
decrypted = await bob.decrypt(ciphertext, iv);
console.log("Bob receives:", new TextDecoder().decode(decrypted));
```

Output:
```
Bob sends: 904851b6e8ccd4c84e14c6d3d26f619247052172d8 a7a2bda259f11e3d2ab56c4a
Alice receives: first
Alice sends: fd8ae90e288a7c86867a38a3698c160a8c89d3e5c1c0 0ee8682f5deafb559da7dca5
Bob receives: second
```
Awesome, we've mastered Double Ratchet. There is just one last thing we need to solve: internet problems.

### Error correction

Imagine this situation: Alice sends 2 messages after each other really fast. Her internet is a bit unstable, and message 1 takes 2 seconds to reach Bob, but message 2 takes only 1 second. So now Bob has got message 2 before message 1, he turns his receive ratchet and... error. Because message 2 requires 2 turns, but Bob doesn't know that, he only turns his receive ratchet once, which generates the key for message 1. Then, Bob receives message 1, turns his receive ratchet and gets the key for message 2. Complete madness, which has its own name: out-of-order messages.

So how do we fix that?

#### Setting up message headers

For the send and receive ratchets, we track the number of messages (starting from 0), call it N. So the first message will be message 0, the second message will be message 1 etc. We'll also store the number of messages in the previous ratchet (the ratchet before a root turn), call it PN. This will also be transmitted with the message in a so called message header. Speaking of message headers, let's implement that too, so we can automate the root ratchet's turning.

```typescript
// utility interfaces
interface RawMessage {
    iv: ArrayBuffer;
    ciphertext: ArrayBuffer;
}

interface Header {
    pubkey: ArrayBuffer;
    N: number;
    PN: number;
}

interface MessageBundle {
    rawMessage: RawMessage;
    header: Header;
}

/**
 * A double ratchet that can encrypt and decrypt messages
 */
class DoubleRatchet {
    ...

    /**
     * Remove/receive key
     */
    #RK: string = "";

    /**
     * Message and previous message numbers for send and receive ratchets
     */
    #SN: number = 0;
    #RN: number = 0;
    #SPN: number = 0;
    #RPN: number = 0; // never actually used, so you can ignore this

    ...

    async turn(pubkey: ArrayBuffer) {
        this.#RK = toHex(pubkey);

        // create a receive ratchet
        let dhOutput = await this.root.turn(pubkey);
        this.#receive = new SymRatchet(dhOutput);
        this.#RPN = this.#RN;
        this.#RN = 0;

        // create a send ratchet (always with a new key)
        dhOutput = await this.root.turn(pubkey, true);
        this.#send = new SymRatchet(dhOutput);
        this.#SPN = this.#SN;
        this.#SN = 0;
    }

    async encrypt(message: ArrayBuffer): Promise<MessageBundle> {
        // generate random IV
        const iv = window.crypto.getRandomValues(new Uint8Array(12));

        // turn the send ratchet to create a message key
        const messageKey = await crypto.importKey("raw", await this.#send.turn(), { name: "AES-GCM", }, false, ["encrypt"]);
        const ciphertext = await crypto.encrypt({ name: "AES-GCM", iv }, messageKey, message);

        const header: Header = {
            pubkey: await this.root.getPubkey(),
            N: this.#SN,
            PN: this.#SPN,
        }

        this.#SN++;

        return { header, rawMessage: { iv, ciphertext } };
    }

    async decrypt(rawMessage: RawMessage) {
        const { iv, ciphertext } = rawMessage;

        // turn the receive ratchet to create a message key
        const messageKey = await crypto.importKey("raw", await this.#receive.turn(), { name: "AES-GCM", }, false, ["decrypt"]);
        const message = await crypto.decrypt({ name: "AES-GCM", iv }, messageKey, ciphertext);

        return message;
    }

    static async build(seed: Uint8Array, pubkey?: ArrayBuffer) {
        const dr = new DoubleRatchet();
        dr.root = await DHRatchet.build(seed);

        if (pubkey) {
            // a new keychain is not needed, since DHRatchet.build() automatically creates a new key pair
            const dhOutput = await dr.root.turn(pubkey);
            dr.#send = new SymRatchet(dhOutput);
        }

        return dr;
    }
}
```

Let's take a look at the changes:
1. There are 3 new utility interfaces: `RawMessage`, `Header` and `MessageBundle`. `RawMessage` contains the ciphertext and the IV, `Header` contains the sender's public key, and the N and PN values of their send ratchet.
2. The `DoubleRatchet` class has now got a bunch of new properties:
    * RK = Remote/receive key, it is the current public key of the other party, stored as its hex representation.
    * The N and PN values for both the send (SN, SPN) and receive (RN, RPN) ratchets.
3. The `setup` function has been massively changed to prepare future code refactors.
    * It has been renamed to `turn`.
    * It only accepts a public key, which it stores in the `RK` variable.
    * Because of the way the root ratchet turns, the receive ratchet is always the first one to get updated turing a root turn. The only exception is the very first root turn, made by the person who accepted a message request (in our example, it's Bob). In that case, the party only needs to generate a send ratchet. This is solved in the `build` function which will automatically create the first send ratchet.
    * After the send and receive ratchets have been replaced, it updates the N and PN values of both ratchets.
4. The `encrypt` function now generates a message header and updates `SN` (note that it is updated after the send ratchet has been turned!).
5. The `decrypt` function now accepts a `RawMessage` object. Note that it should also update `RN`, but we're later going to completely refactor this function, so it doesn't matter anyway.
6. The `build` function now takes in an optional public key (in case it is receiving a message request). If that public key is set, it automatically creates the send ratchet.

Using the double ratchet now simplifies a lot.

```typescript
const seed = window.crypto.getRandomValues(new Uint8Array(32));

const alice = await DoubleRatchet.build(seed);
const bob = await DoubleRatchet.build(seed, await alice.root.getPubkey());

// Bob sends a message to Alice
const message = await bob.encrypt(new TextEncoder().encode("Hello Alice!"));
console.log("Bob sends:");
console.dir(message);

// Alice receives the message
const decrypted = await alice.processMessage(message);
console.log("Alice receives:", new TextDecoder().decode(decrypted));
```

Output
```
Bob sends:
Object
    header: {pubkey: ArrayBuffer(65), N: 0, PN: 0}
    rawMessage: {iv: Uint8Array(12), ciphertext: ArrayBuffer(28)}
Alice receives: Hello Alice!
```

### Automating message processing

So let's talk about how we can use these N and PN parameters. Let's say Bob sends us 4 messages, message 1 arrives correctly, but message 2 and 3 get skipped and we only get message 4. If we take a look at the headers, this is what we should see: message 1 has a `N` of 0, but message 4 has a `N` of 3. Don't forget that every time we receive a message, we also increase `RN` by one. So when receiving message 4, `RN` is 1. Based on Signal's document, there are 2 possible options here:
1. A root ratchet turn was NOT triggered (= both messages come from the same send ratchet, PN is irrelevant): the count of messages skipped = `N` - `RN` = 3 - 1 = 2. This is true: we've skipped 2 messages: message 2 and 3.
2. A root ratchet turn was triggered (= the latest message does not come from the same send ratchet): this is a bit trickier. Imagine Bob sent message 1, we sent back another message which triggers a root ratchet turn for Bob. Now he sends message 2 and 3 again, but they get skipped and we only receive message 4. Message 4's header will have a `N` of 2 (it's the 3rd message in Bob's new send ratchet) and a `PN` of 1 (= Bob's previous send ratchet had 1 message, which was message 1). In this case, the count of messages skipped *in Bob's previous send ratchet* = `PN` - `RN` = 1 - 1 = 0. This is true, we have not skipped any messages in Bob's previous send ratchet. The count of messages skipped *in Bob's new send ratchet* = `N` = 2. This is true, we've skipped 2 messages: message 2 and 3.

To make sure we can decrypt skipped messages, we'll store every message key which wasn't used right away in a list. This list will use the public key and `N` variable of the message to identify it.

This is the pseudocode of what we'll do when receiving a message:
1. We look at the list of skipped message keys, mapped by the message's public key and `N` value. If a corresponding message key was found, we use that to decrypt the message, then delete that key.
2. We calculate if we've skipped any messages in the previous send ratchet. We turn our receive ratchet that many times and store all keys in our list (we can use the stored `RK` to correctly identify these messages).
3. If needed, we turn our root ratchet.
4. We calculate if we've skipped any messages in the current send ratchet. We store the message keys like before.
5. We decrypt and return the message.

I'm super excited, so let's do it!

```typescript
class DoubleRatchet {
    ...

    #skippedKeys = new Array<{ pubkey: string, N: number, key: ArrayBuffer }>();

    ...

    async #turn(pubkey: ArrayBuffer) {
        ...
    }

    async #decrypt(rawMessage: RawMessage, messageKey: CryptoKey) {
        const { iv, ciphertext } = rawMessage;

        // decrypt the message
        const message = await crypto.decrypt({ name: "AES-GCM", iv }, messageKey, ciphertext);

        return message;
    }

    async processMessage(message: MessageBundle) {
        // check if we already have a key for this message
        const skippedKey = this.#skippedKeys.find(k => k.pubkey === toHex(message.header.pubkey) && k.N === message.header.N)?.key;
        if (skippedKey) {
            const messageKey = await crypto.importKey("raw", skippedKey, { name: "AES-GCM" }, false, ["decrypt"]);
            this.#skippedKeys.splice(this.#skippedKeys.findIndex(k => toHex(k.key) === toHex(skippedKey)), 1); // remove the key from the skipped keys array
            return this.#decrypt(message.rawMessage, messageKey);
        }

        const doTurn = this.#RK !== toHex(message.header.pubkey);

        // calculate the number of skipped messages in the previous ratchet
        if (doTurn) {
            const skippedPrev = message.header.PN - this.#RN;
            for (let i = 0; i < skippedPrev; i++) {
                const key = await this.#receive.turn();
                this.#skippedKeys.push({ pubkey: toHex(message.header.pubkey), N: i, key });
            }
        }

        // do a turn if needed
        if (doTurn) await this.#turn(message.header.pubkey);

        // calculate the number of skipped messages in the current ratchet
        const skipped = doTurn ? message.header.N : message.header.N - this.#RN;
        const offset = doTurn ? 0 : this.#RN; // this is needed to correctly calculate the skipped keys
        for (let i = 0; i < skipped; i++) {
            const key = await this.#receive.turn();
            this.#skippedKeys.push({ pubkey: toHex(message.header.pubkey), N: i + offset, key });
        }

        // update RN
        this.#RN = message.header.N + 1;

        // decrypt the message
        const messageKey = await crypto.importKey("raw", await this.#receive.turn(), { name: "AES-GCM" }, false, ["decrypt"]);
        return this.#decrypt(message.rawMessage, messageKey);
    }

    ...
}
```

Functions `decrypt` and `turn` have become a private function and `decrypt` no longer turns the receive ratchet manually, it requires the correct message key. The `processMessage` function is basically just what the pseudocode says, but as actual code. Note that `RN` has to be set to the message's `N` value + 1 (it's basically `RN` = `N` -> decrypt -> `RN++` simplied). There is also a new `skippedKeys` property which is an array that holds all the skipped keys (I had to use an array, because the JavaScript Map doesn't like keys that are objects and not a primitive).

#### Basic example

Sending messages now becomes stupidly simple.

```typescript
const seed = window.crypto.getRandomValues(new Uint8Array(32));

const alice = await DoubleRatchet.build(seed);
const bob = await DoubleRatchet.build(seed, await alice.root.getPubkey());

// Bob sends a message to Alice
const message = await bob.encrypt(new TextEncoder().encode("Hello Alice!"));
console.log("Bob sends:", JSON.stringify({ header: { N: message.header.N, PN: message.header.PN, pubkey: toHex(message.header.pubkey) }, rawMessage: { iv: toHex(message.rawMessage.iv), ciphertext: toHex(message.rawMessage.ciphertext) } }));

// Alice receives the message
const decrypted = await alice.processMessage(message);
console.log("Alice receives:", new TextDecoder().decode(decrypted));
```

All the root turning and stuff we had to do previously is now compressed into a single function.

Output (first try actually lmao):
```
Bob sends: {"header":{"N":0,"PN":0,"pubkey":"044d9223578506aaf81ea3963227f98bf4ac3a18e98491ea39dac98ce88594648179a40d8a2d00eea74fb2078251f79b2d160d2fa3e86d07374f9907d7f5740472"},"rawMessage":{"iv":"619774accecaed2a4a619d11","ciphertext":"b826eac99309d27dfef772c185b6af36cc82bed3ba354a814fa1e10e"}}
Alice receives: Hello Alice!
```

#### Skipping messages

Now obviously, we've come this far to handle out-of-order messages. So let's do that! We will skip message 2 and 3 without a root turn.

```typescript
const seed = window.crypto.getRandomValues(new Uint8Array(32));

const alice = await DoubleRatchet.build(seed);
const bob = await DoubleRatchet.build(seed, await alice.root.getPubkey());

// Bob sends a message to Alice
const message1 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 1!"));
const message2 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 2!"));
const message3 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 3!"));
const message4 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 4!"));

// Message 1 arrives, but 2 and 3 are lost
const decrypted1 = await alice.processMessage(message1);
console.log("Alice receives:", new TextDecoder().decode(decrypted1));

// Message 4 arrives
const decrypted4 = await alice.processMessage(message4);
console.log("Alice receives:", new TextDecoder().decode(decrypted4));

// Message 2 and 3 arrive
const decrypted2 = await alice.processMessage(message2);
console.log("Alice receives:", new TextDecoder().decode(decrypted2));

const decrypted3 = await alice.processMessage(message3);
console.log("Alice receives:", new TextDecoder().decode(decrypted3));
```

Output (I admit this wasn't first try, this is when I found out about that JavaScript Map thing I mentioned earlier):
```
Alice receives: Hello Alice, this is message 1!
Alice receives: Hello Alice, this is message 4!
Alice receives: Hello Alice, this is message 2!
Alice receives: Hello Alice, this is message 3!
```

Let's also test skipping messages in the previous chain!

```typescript
const seed = window.crypto.getRandomValues(new Uint8Array(32));

const alice = await DoubleRatchet.build(seed);
const bob = await DoubleRatchet.build(seed, await alice.root.getPubkey());

// Bob sends a message to Alice
const message1 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 1!"));

// Alice receives the message
const decrypted1 = await alice.processMessage(message1);
console.log("Alice receives:", new TextDecoder().decode(decrypted1));

// Alice sends a message to Bob to trigger a DH ratchet turn
const message2 = await alice.encrypt(new TextEncoder().encode("Hello Bob, this is message 2!"));

// Bob receives the message
const decrypted2 = await bob.processMessage(message2);
console.log("Bob receives:", new TextDecoder().decode(decrypted2));

// Bob sends message 3, 4 and 5
const message3 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 3!"));
const message4 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 4!"));
const message5 = await bob.encrypt(new TextEncoder().encode("Hello Alice, this is message 5!"));

// Messages 3 and 4 are skipped

// Alice receives message 5
const decrypted5 = await alice.processMessage(message5);
console.log("Alice receives:", new TextDecoder().decode(decrypted5));

// Messages 3 and 4 are received
const decrypted3 = await alice.processMessage(message3);
console.log("Alice receives:", new TextDecoder().decode(decrypted3));
const decrypted4 = await alice.processMessage(message4);
console.log("Alice receives:", new TextDecoder().decode(decrypted4));
```

Output:
```
Alice receives: Hello Alice, this is message 1!
Bob receives: Hello Bob, this is message 2!
Alice receives: Hello Alice, this is message 5!
Alice receives: Hello Alice, this is message 3!
Alice receives: Hello Alice, this is message 4!
```

The final code can be viewed <a href="/files/double-ratchet.ts" download="double-ratchet.ts">here</a>.

### Extra notes

Well congratulations, you've finally completed implementing the Double Ratchet algorithm, give yourself a hug or something.

There are still some final stuff you could improve on:
1. Currently, there is no limit to how many skipped message keys can be stored. The Signal document recommends creating one, since an attacker could send a bunch of fake messages that would just steal computational power. In practice, this limit is around 1000.
2. In our controlled environment the messages sent between Alice and Bob are supervised, but in a real world attackers could try sending random fake messages to the parties. This won't cause problems, but the code doesn't handle decryption problems yet. This means, that if a fake (or even corrupted) message is received, it'll just throw an uncatched error.
3. The headers are not encrypted. This could theoretically give the option for attackers (or the server itself) to modify the header, which can cause unwanted effects. Signal's document [mentions how you could encrypt the headers](https://signal.org/docs/specifications/doubleratchet/#double-ratchet-with-header-encryption), but I haven't mentioned that here, since the code is already too complicated. The easiest solution is to just include a digital signature for the header anyway, although in some cases it might be required to not only prevent modification, but also reading.

Anyway, have fun!

# Final thoughts

This thing is complicated.

# Coming soon: Matrix's ratchet for group communication: Megolm